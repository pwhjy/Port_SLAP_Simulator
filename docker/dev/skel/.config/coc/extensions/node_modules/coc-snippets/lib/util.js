"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const pify_1 = tslib_1.__importDefault(require("pify"));
const fs_1 = tslib_1.__importDefault(require("fs"));
function replaceText(content, items) {
    let res = '';
    items.sort((a, b) => a.index - b.index);
    let item = items.shift();
    for (let i = 0; i < content.length; i++) {
        let idx = item ? item.index : null;
        if (idx == null || i != idx) {
            res = res + content[i];
            continue;
        }
        res = res + item.newText;
        i = i + item.length;
    }
    return res;
}
exports.replaceText = replaceText;
function flatten(arr) {
    return arr.reduce((p, curr) => p.concat(curr), []);
}
exports.flatten = flatten;
async function statAsync(filepath) {
    try {
        return await pify_1.default(fs_1.default.stat)(filepath);
    }
    catch (e) {
        return null;
    }
}
exports.statAsync = statAsync;
async function writeFileAsync(fullpath, content) {
    await pify_1.default(fs_1.default.writeFile)(fullpath, content, 'utf8');
}
exports.writeFileAsync = writeFileAsync;
async function readFileAsync(fullpath, encoding = 'utf8') {
    return await pify_1.default(fs_1.default.readFile)(fullpath, encoding);
}
exports.readFileAsync = readFileAsync;
async function readdirAsync(filepath) {
    try {
        return await pify_1.default(fs_1.default.readdir)(filepath);
    }
    catch (e) {
        return null;
    }
}
exports.readdirAsync = readdirAsync;
function headTail(line) {
    line = line.trim();
    let ms = line.match(/^(\S+)\s+(.*)/);
    if (!ms)
        return [line, ''];
    return [ms[1], ms[2]];
}
exports.headTail = headTail;
function memorize(_target, key, descriptor) {
    let fn = descriptor.get;
    if (typeof fn !== 'function')
        return;
    let memoKey = '$' + key;
    descriptor.get = function (...args) {
        if (this.hasOwnProperty(memoKey))
            return Promise.resolve(this[memoKey]);
        return new Promise((resolve, reject) => {
            Promise.resolve(fn.apply(this, args)).then(res => {
                this[memoKey] = res;
                resolve(res);
            }, e => {
                reject(e);
            });
        });
    };
}
exports.memorize = memorize;
function trimQuote(str) {
    if (str.startsWith('"') || str.startsWith("'"))
        return str.slice(1, -1);
    return str;
}
exports.trimQuote = trimQuote;
function distinct(array, keyFn) {
    if (!keyFn) {
        return array.filter((element, position) => {
            return array.indexOf(element) === position;
        });
    }
    const seen = Object.create(null);
    return array.filter(elem => {
        const key = keyFn(elem);
        if (seen[key]) {
            return false;
        }
        seen[key] = true;
        return true;
    });
}
exports.distinct = distinct;
const conditionRe = /\(\?\(\?:\w+\).+\|/;
const bellRe = /\\a/;
const commentRe = /\(\?#.*?\)/;
const stringStartRe = /\\A/;
const namedCaptureRe = /\(\?P<\w+>.*?\)/;
const namedReferenceRe = /\(\?P=(\w+)\)/;
const braceRe = /\^\]/;
const regex = new RegExp(`${bellRe.source}|${commentRe.source}|${stringStartRe.source}|${namedCaptureRe.source}|${namedReferenceRe.source}|${braceRe}`, 'g');
/**
 * Convert python regex to javascript regex,
 * throw error when unsupported pattern found
 *
 * @public
 * @param {string} str
 * @returns {string}
 */
function convertRegex(str) {
    if (str.indexOf('\\z') !== -1) {
        throw new Error('pattern \\z not supported');
    }
    if (str.indexOf('(?s)') !== -1) {
        throw new Error('pattern (?s) not supported');
    }
    if (str.indexOf('(?x)') !== -1) {
        throw new Error('pattern (?x) not supported');
    }
    if (str.indexOf('\n') !== -1) {
        throw new Error('multiple line pattern not supported');
    }
    if (conditionRe.test(str)) {
        throw new Error('condition pattern not supported');
    }
    return str.replace(regex, (match, p1) => {
        if (match == '^]')
            return '^\\]';
        if (match == '\\a')
            return '';
        if (match.startsWith('(?#'))
            return '';
        if (match == '\\A')
            return '^';
        if (match.startsWith('(?P<'))
            return '(?' + match.slice(3);
        if (match.startsWith('(?P='))
            return `\\k<${p1}>`;
        return '';
    });
}
exports.convertRegex = convertRegex;
function wait(ms) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
}
exports.wait = wait;
function getRegexText(prefix) {
    if (prefix.startsWith('^'))
        prefix = prefix.slice(1);
    if (prefix.endsWith('$'))
        prefix = prefix.slice(0, -1);
    let content = prefix.replace(/\(.*\)\??/g, '');
    content = content.replace(/\\/g, '');
    return content;
}
exports.getRegexText = getRegexText;
function markdownBlock(code, filetype) {
    filetype = filetype == 'javascriptreact' ? 'javascript' : filetype;
    filetype = filetype == 'typescriptreact' ? 'typescript' : filetype;
    return '``` ' + filetype + '\n' + code + '\n```';
}
exports.markdownBlock = markdownBlock;
//# sourceMappingURL=util.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const coc_nvim_1 = require("coc.nvim");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = tslib_1.__importDefault(require("util"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const snippet_1 = tslib_1.__importDefault(require("./list/snippet"));
const provider_1 = require("./provider");
const snipmateProvider_1 = require("./snipmateProvider");
const textmateProvider_1 = require("./textmateProvider");
const ultisnipsProvider_1 = require("./ultisnipsProvider");
const util_2 = require("./util");
const languages_1 = tslib_1.__importDefault(require("./languages"));
const docs = `# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly $\{1} = new Emitter<$2>()
#		public readonly $\{1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
`;
async function activate(context) {
    let { subscriptions } = context;
    const { nvim } = coc_nvim_1.workspace;
    const configuration = coc_nvim_1.workspace.getConfiguration('snippets');
    const filetypeExtends = configuration.get('extends', {});
    const manager = new provider_1.ProviderManager();
    const trace = configuration.get('trace', 'error');
    let mru = coc_nvim_1.workspace.createMru('snippets-mru');
    const channel = coc_nvim_1.workspace.createOutputChannel('snippets');
    const snippetsDir = path_1.default.join(path_1.default.dirname(coc_nvim_1.workspace.env.extensionRoot), 'ultisnips');
    if (!fs_1.default.existsSync(snippetsDir)) {
        await util_1.default.promisify(fs_1.default.mkdir)(snippetsDir);
    }
    coc_nvim_1.events.on('CompleteDone', async (item) => {
        if (item.user_data && item.user_data.indexOf('snippets') !== -1) {
            await mru.add(item.word);
        }
    }, null, subscriptions);
    coc_nvim_1.workspace.onDidOpenTextDocument(async (document) => {
        if (document.uri.endsWith('.snippets')) {
            let doc = coc_nvim_1.workspace.getDocument(document.uri);
            if (!doc)
                return;
            let { buffer } = doc;
            await buffer.setOption('filetype', 'snippets');
        }
    }, null, subscriptions);
    if (configuration.get('ultisnips.enable', true)) {
        let config = configuration.get('ultisnips', {});
        let c = Object.assign({}, config, {
            extends: Object.assign({}, filetypeExtends)
        });
        c.directories = c.directories ? c.directories.slice() : [];
        if (c.directories.indexOf(snippetsDir) == -1) {
            c.directories.push(snippetsDir);
        }
        let provider = new ultisnipsProvider_1.UltiSnippetsProvider(channel, trace, c);
        manager.regist(provider, 'ultisnips');
        subscriptions.push(provider);
        // add rtp if ultisnips not found
        nvim.getOption('runtimepath').then(async (rtp) => {
            let paths = rtp.split(',');
            let idx = paths.findIndex(s => /^ultisnips$/i.test(path_1.default.basename(s)));
            if (idx !== -1)
                return;
            let directory = path_1.default.resolve(__dirname, '..');
            nvim.command('autocmd BufNewFile,BufRead *.snippets setf snippets', true);
            nvim.command(`execute 'noa set rtp^='.fnameescape('${directory.replace(/'/g, "''")}')`, true);
            coc_nvim_1.workspace.documents.forEach(doc => {
                if (doc.uri.endsWith('.snippets')) {
                    doc.buffer.setOption('filetype', 'snippets', true);
                }
            });
        }, _e => {
            // noop
        });
    }
    let config = {
        loadFromExtensions: configuration.get('loadFromExtensions', true),
        snippetsRoots: configuration.get('textmateSnippetsRoots', []),
        extends: Object.assign({}, filetypeExtends)
    };
    let provider = new textmateProvider_1.TextmateProvider(channel, trace, config);
    manager.regist(provider, 'snippets');
    if (configuration.get('snipmate.enable', true)) {
        let config = {
            author: configuration.get('snipmate.author', ''),
            extends: Object.assign({}, filetypeExtends)
        };
        let provider = new snipmateProvider_1.SnipmateProvider(channel, trace, config);
        manager.regist(provider, 'snipmate');
    }
    if (configuration.get('autoTrigger', true)) {
        let insertTs;
        let lastChange;
        coc_nvim_1.events.on('InsertCharPre', () => {
            insertTs = Date.now();
        });
        coc_nvim_1.events.on(['TextChangedI', 'TextChangedP'], async () => {
            if (!insertTs || Date.now() - insertTs > 50)
                return;
            let now = lastChange = Date.now();
            let curr = insertTs;
            await util_2.wait(50);
            let edits = await manager.getTriggerSnippets(true);
            if (insertTs != curr || now != lastChange || edits.length == 0)
                return;
            if (edits.length > 1) {
                channel.appendLine(`Multiple snippet found for auto trigger: ${edits.map(s => s.prefix).join(', ')}`);
                coc_nvim_1.workspace.showMessage('Multiple snippet found for auto trigger, check output by :CocCommand workspace.showOutput', 'warning');
            }
            await coc_nvim_1.commands.executeCommand('editor.action.insertSnippet', edits[0]);
            await mru.add(edits[0].prefix);
        }, null, subscriptions);
    }
    const statusItem = coc_nvim_1.workspace.createStatusBarItem(90, { progress: true });
    statusItem.text = 'loading snippets';
    statusItem.show();
    manager.init().then(() => {
        statusItem.hide();
    }, e => {
        statusItem.hide();
        coc_nvim_1.workspace.showMessage(`Error on load snippets: ${e.message}`, 'error');
    });
    if (manager.hasProvider) {
        let disposable = coc_nvim_1.languages.registerCompletionItemProvider('snippets', 'S', null, manager, configuration.get('triggerCharacters', []), configuration.get('priority', 90));
        subscriptions.push(disposable);
    }
    async function fallback() {
        await nvim.call('coc#start', [{ source: 'snippets' }]);
    }
    async function doExpand() {
        let edits = await manager.getTriggerSnippets();
        if (edits.length == 0)
            return false;
        if (edits.length == 1) {
            await coc_nvim_1.commands.executeCommand('editor.action.insertSnippet', edits[0]);
            await mru.add(edits[0].prefix);
        }
        else {
            let idx = await coc_nvim_1.workspace.showQuickpick(edits.map(e => e.description || e.prefix), 'choose snippet:');
            if (idx == -1)
                return;
            await coc_nvim_1.commands.executeCommand('editor.action.insertSnippet', edits[idx]);
            await mru.add(edits[idx].prefix);
        }
        return true;
    }
    subscriptions.push(coc_nvim_1.commands.registerCommand('snippets.editSnippets', async () => {
        let buf = await nvim.buffer;
        let doc = coc_nvim_1.workspace.getDocument(buf.id);
        if (!doc || !doc.filetype)
            return;
        let file = path_1.default.join(snippetsDir, `${doc.filetype}.snippets`);
        if (!fs_1.default.existsSync(file)) {
            await util_1.default.promisify(fs_1.default.writeFile)(file, docs, 'utf8');
        }
        let uri = vscode_uri_1.default.file(file).toString();
        await coc_nvim_1.workspace.jumpTo(uri);
    }));
    subscriptions.push(coc_nvim_1.workspace.registerKeymap(['i'], 'snippets-expand', async () => {
        let expanded = await doExpand();
        if (!expanded)
            await fallback();
    }, { silent: true, sync: true, cancel: false }));
    subscriptions.push(coc_nvim_1.workspace.registerKeymap(['i'], 'snippets-expand-jump', async () => {
        let expanded = await doExpand();
        if (!expanded) {
            let bufnr = await nvim.call('bufnr', '%');
            let session = coc_nvim_1.snippetManager.getSession(bufnr);
            if (session && session.isActive) {
                await nvim.call('coc#_cancel', []);
                await coc_nvim_1.snippetManager.nextPlaceholder();
                return;
            }
            await fallback();
        }
    }, { silent: true, sync: true, cancel: false }));
    subscriptions.push(coc_nvim_1.workspace.registerKeymap(['v'], 'snippets-select', async () => {
        let doc = await coc_nvim_1.workspace.document;
        if (!doc)
            return;
        let mode = await nvim.call('mode');
        if (['v', 'V'].indexOf(mode) == -1) {
            coc_nvim_1.workspace.showMessage('select of visual block not supported', 'warning');
            return;
        }
        await nvim.call('feedkeys', [String.fromCharCode(27), 'in']);
        await nvim.command('normal! `<');
        let start = await coc_nvim_1.workspace.getCursorPosition();
        await nvim.command('normal! `>');
        let end = await coc_nvim_1.workspace.getCursorPosition();
        end = vscode_languageserver_types_1.Position.create(end.line, end.character + 1);
        let range = vscode_languageserver_types_1.Range.create(start, end);
        let text = doc.textDocument.getText(range);
        await nvim.call('feedkeys', ['i', 'in']);
        if (mode == 'v') {
            await doc.applyEdits(coc_nvim_1.workspace.nvim, [{ range, newText: '' }]);
        }
        else {
            // keep indent
            let currline = doc.getline(start.line);
            let indent = currline.match(/^\s*/)[0];
            let lines = text.split(/\r?\n/);
            lines = lines.map(s => s.startsWith(indent) ? s.slice(indent.length) : s);
            text = lines.join('\n');
            range = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(start.line, indent.length), end);
            await doc.applyEdits(coc_nvim_1.workspace.nvim, [{ range, newText: '' }]);
        }
        await nvim.setVar('coc_selected_text', text);
        await coc_nvim_1.workspace.moveTo(range.start);
    }, { silent: true, sync: false, cancel: true }));
    let languageProvider = new languages_1.default(channel, trace);
    coc_nvim_1.languages.registerCompletionItemProvider('snippets-source', 'S', ['snippets'], languageProvider, ['$']);
    subscriptions.push(statusItem);
    subscriptions.push(channel);
    subscriptions.push(coc_nvim_1.listManager.registerList(new snippet_1.default(coc_nvim_1.workspace.nvim, manager, mru)));
    return {
        expandable: async () => {
            let edits = await manager.getTriggerSnippets();
            return edits && edits.length > 0;
        }
    };
}
exports.activate = activate;
//# sourceMappingURL=index.js.map
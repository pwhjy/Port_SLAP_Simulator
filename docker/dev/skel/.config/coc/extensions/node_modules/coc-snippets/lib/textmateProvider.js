"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const fs_1 = tslib_1.__importDefault(require("fs"));
const jsonc_parser_1 = require("jsonc-parser");
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = tslib_1.__importDefault(require("util"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const baseProvider_1 = tslib_1.__importDefault(require("./baseProvider"));
const types_1 = require("./types");
class TextmateProvider extends baseProvider_1.default {
    constructor(channel, trace, config) {
        super(config);
        this.channel = channel;
        this.trace = trace;
        this._snippetCache = {};
        this._userSnippets = {};
        if (config.loadFromExtensions) {
            coc_nvim_1.extensions.onDidLoadExtension(extension => {
                this.loadSnippetsFromExtension(extension).catch(e => {
                    channel.appendLine(`[Error] ${e.message}`);
                });
            });
            coc_nvim_1.extensions.onDidUnloadExtension(id => {
                delete this._snippetCache[id];
            });
        }
    }
    async init() {
        if (this.config.loadFromExtensions) {
            for (let extension of coc_nvim_1.extensions.all) {
                await this.loadSnippetsFromExtension(extension);
            }
        }
        let paths = this.config.snippetsRoots;
        if (paths && paths.length) {
            for (let dir of paths) {
                await this.loadSnippetsFromRoot(dir);
            }
        }
    }
    async getSnippetFiles() {
        return [];
    }
    async getTriggerSnippets(document, position, autoTrigger) {
        if (autoTrigger)
            return [];
        let line = document.getline(position.line);
        line = line.slice(0, position.character);
        let snippets = await this.getSnippets();
        if (!snippets || !snippets.length)
            return [];
        let edits = [];
        for (let snip of snippets) {
            let { prefix } = snip;
            if (!line.endsWith(prefix))
                continue;
            let pre = line.slice(0, line.length - prefix.length);
            // only allow in line begin
            if (pre.trim().length)
                continue;
            edits.push({
                prefix,
                range: vscode_languageserver_types_1.Range.create(position.line, position.character - prefix.length, position.line, position.character),
                newText: snip.body,
                location: snip.filepath,
                description: snip.description,
                priority: -1
            });
        }
        return edits;
    }
    async getSnippets() {
        let res = [];
        let filetypes = await this.getFiletypes();
        let added = new Set();
        for (let key of Object.keys(this._snippetCache)) {
            let cache = this._snippetCache[key];
            for (let filetype of filetypes) {
                let snippets = cache[filetype];
                if (snippets) {
                    for (let snip of snippets) {
                        if (!added.has(snip.prefix)) {
                            added.add(snip.prefix);
                            res.push(snip);
                        }
                    }
                }
            }
        }
        for (let filetype of filetypes) {
            let snippets = this._userSnippets[filetype];
            if (snippets && snippets.length) {
                for (let snip of snippets) {
                    if (!added.has(snip.prefix)) {
                        added.add(snip.prefix);
                        res.push(snip);
                    }
                }
            }
        }
        return res;
    }
    async resolveSnippetBody(snip, _range) {
        return snip.body;
    }
    async loadSnippetsFromExtension(extension) {
        let { packageJSON } = extension;
        if (packageJSON.contributes && packageJSON.contributes.snippets) {
            let { snippets } = packageJSON.contributes;
            let map = new Map();
            let def = {
                extensionId: extension.id,
                snippets: map
            };
            for (let item of snippets) {
                let p = path_1.default.join(extension.extensionPath, item.path);
                let { language } = item;
                let ids = map.get(p) || [];
                ids.push(language);
                map.set(p, ids);
            }
            if (snippets && snippets.length) {
                await this.loadSnippetsFromDefinition(def);
            }
        }
    }
    async loadSnippetsFromRoot(root) {
        let { _userSnippets } = this;
        if (root.startsWith('~'))
            root = root.replace(/^~/, os_1.default.homedir());
        let files = await util_1.default.promisify(fs_1.default.readdir)(root, 'utf8');
        files = files.filter(f => f.endsWith('.json') || f.endsWith('.code-snippets'));
        await Promise.all(files.map(file => {
            file = path_1.default.join(root, file);
            let basename = path_1.default.basename(file, '.json');
            basename = basename.replace(/\.code-snippets$/, '');
            return this.loadSnippetsFromFile(file).then(snippets => {
                _userSnippets[basename] = snippets;
            });
        }));
    }
    async loadSnippetsFromDefinition(def) {
        let { extensionId, snippets } = def;
        let cache = this._snippetCache[extensionId] = {};
        for (let path of snippets.keys()) {
            let arr = await this.loadSnippetsFromFile(path);
            let languageIds = snippets.get(path);
            for (let id of languageIds) {
                cache[id] = arr;
            }
        }
    }
    async loadSnippetsFromFile(snippetFilePath) {
        const contents = await new Promise((resolve, reject) => {
            fs_1.default.readFile(snippetFilePath, "utf8", (err, data) => {
                if (err)
                    return reject(err);
                resolve(data);
            });
        });
        const snippets = this.loadSnippetsFromText(snippetFilePath, contents);
        if (this.trace == 'verbose') {
            this.channel.appendLine(`[Info ${(new Date()).toLocaleDateString()}] Loaded ${snippets.length} snippets from ${snippetFilePath}`);
        }
        return snippets;
    }
    loadSnippetsFromText(filepath, contents) {
        let snippets = [];
        try {
            let errors = [];
            let snippetObject = jsonc_parser_1.parse(contents, errors, { allowTrailingComma: true });
            if (errors.length) {
                this.channel.appendLine(`[Error ${(new Date()).toLocaleDateString()}] parser error: ${errors[0].error}`);
            }
            if (snippetObject) {
                for (let key of Object.keys(snippetObject)) {
                    snippets.push(snippetObject[key]);
                }
            }
        }
        catch (ex) {
            this.channel.appendLine(`[Error ${(new Date()).toLocaleDateString()}] ${ex.stack}`);
            snippets = [];
        }
        const normalizedSnippets = snippets.map((snip) => {
            return {
                filepath,
                lnum: 0,
                body: typeof snip.body === 'string' ? snip.body : snip.body.join(os_1.default.EOL),
                prefix: snip.prefix,
                description: snip.description,
                triggerKind: types_1.TriggerKind.LineBegin
            };
        });
        return normalizedSnippets;
    }
}
exports.TextmateProvider = TextmateProvider;
//# sourceMappingURL=textmateProvider.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const coc_nvim_1 = require("coc.nvim");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const readline_1 = tslib_1.__importDefault(require("readline"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const baseProvider_1 = tslib_1.__importDefault(require("./baseProvider"));
const types_1 = require("./types");
const util_1 = require("./util");
const parser_1 = tslib_1.__importDefault(require("./parser"));
class SnipmateProvider extends baseProvider_1.default {
    constructor(channel, trace, config) {
        super(config);
        this.channel = channel;
        this.trace = trace;
        this.snippetFiles = [];
        this.disposables = [];
        coc_nvim_1.workspace.onDidSaveTextDocument(async (doc) => {
            let filepath = vscode_uri_1.default.parse(doc.uri).fsPath;
            let snippetFile = this.snippetFiles.find(s => s.filepath == filepath);
            if (snippetFile)
                await this.loadSnippetsFromFile(snippetFile.filetype, snippetFile.directory, filepath);
        }, null, this.disposables);
    }
    async init() {
        let arr = await this.getAllSnippetFiles();
        let { nvim } = coc_nvim_1.workspace;
        let author = await nvim.getVar('snips_author');
        if (!author)
            await nvim.setVar('snips_author', this.config.author);
        await Promise.all(arr.map(({ filepath, directory, filetype }) => {
            return this.loadSnippetsFromFile(filetype, directory, filepath);
        }));
    }
    async loadSnippetsFromFile(filetype, directory, filepath) {
        let snippets = await this.parseSnippetsFile(filepath);
        let idx = this.snippetFiles.findIndex(o => o.filepath == filepath);
        if (idx !== -1)
            this.snippetFiles.splice(idx, 1);
        this.snippetFiles.push({
            directory,
            filepath,
            filetype,
            snippets
        });
        if (this.trace == 'verbose') {
            this.channel.appendLine(`[Info ${(new Date()).toLocaleTimeString()}] Loaded ${snippets.length} snippets from: ${filepath}`);
        }
    }
    /**
     * Resolve snippet body to inserted text.
     *
     * @public
     * @param {Snippet} snippet
     * @param {Range} _range
     * @param {string} _line
     * @returns {Promise<string>}
     */
    async resolveSnippetBody(snippet, _range, _line) {
        let parser = new parser_1.default(snippet.body);
        let resolved = '';
        let { nvim } = coc_nvim_1.workspace;
        while (!parser.eof()) {
            if (parser.curr == '`') {
                let idx = parser.nextIndex('`', true, false);
                if (idx == -1) {
                    resolved = resolved + parser.eatTo(parser.len);
                    break;
                }
                let code = parser.eatTo(idx + 1);
                code = code.slice(1, -1);
                if (code.startsWith('Filename')) {
                    resolved = resolved + await nvim.call('expand', '%:p:t');
                }
                else {
                    try {
                        resolved = resolved + await nvim.eval(code);
                    }
                    catch (e) {
                        this.channel.appendLine(`[Error ${(new Date()).toLocaleTimeString()}] Error on eval: ${code}`);
                    }
                }
                continue;
            }
            parser.iterate(ch => {
                if (ch == '`') {
                    return false;
                }
                else {
                    resolved = resolved + ch;
                }
                return true;
            });
        }
        return resolved;
    }
    /**
     * Parse snippets from snippets file.
     *
     * @public
     * @param {string} filepath
     * @returns {Promise<Snippet[]>}
     */
    parseSnippetsFile(filepath) {
        let res = [];
        const rl = readline_1.default.createInterface({
            input: fs_1.default.createReadStream(filepath, 'utf8'),
            crlfDelay: Infinity
        });
        let lnum = 0;
        let lines = [];
        let prefix = '';
        let description = '';
        rl.on('line', line => {
            lnum += 1;
            if (line.startsWith('#'))
                return;
            if (line.startsWith('snippet')) {
                line = line.replace(/\s*$/, '');
                if (lines.length && prefix) {
                    res.push({
                        filepath,
                        lnum: lnum - lines.length - 1,
                        body: lines.join('\n').replace(/\s+$/, ''),
                        prefix,
                        description,
                        triggerKind: types_1.TriggerKind.SpaceBefore
                    });
                    lines = [];
                }
                let ms = line.match(/^snippet\s+(\S+)(?:\s(.+))?$/);
                if (!ms) {
                    prefix = '';
                    this.channel.appendLine(`[Error ${(new Date()).toLocaleTimeString()}] Broken line on ${filepath}:${lnum}`);
                    return;
                }
                prefix = ms[1];
                description = ms[2] || '';
                return;
            }
            if (prefix) {
                if (line.startsWith('\t')) {
                    lines.push(line.slice(1));
                }
                else {
                    lines.push(line);
                }
            }
        });
        return new Promise(resolve => {
            rl.on('close', async () => {
                if (lines.length) {
                    res.push({
                        filepath,
                        lnum: lnum - lines.length - 1,
                        body: lines.join('\n'),
                        prefix,
                        description,
                        triggerKind: types_1.TriggerKind.SpaceBefore
                    });
                }
                resolve(res);
            });
        });
    }
    async getTriggerSnippets(document, position, autoTrigger) {
        if (autoTrigger)
            return [];
        let snippets = await this.getSnippets();
        let line = document.getline(position.line);
        line = line.slice(0, position.character);
        if (!line || line[line.length - 1] == ' ')
            return [];
        snippets = snippets.filter(s => {
            let { prefix } = s;
            if (!line.endsWith(prefix))
                return false;
            let pre = line.slice(0, line.length - prefix.length);
            return pre.length == 0 || /\s/.test(pre[pre.length - 1]);
        });
        let edits = [];
        for (let s of snippets) {
            let character = position.character - s.prefix.length;
            let range = vscode_languageserver_types_1.Range.create(position.line, character, position.line, position.character);
            let newText = await this.resolveSnippetBody(s, range, line);
            edits.push({
                prefix: s.prefix,
                description: s.description,
                location: s.filepath,
                range,
                newText,
                priority: -1
            });
        }
        return edits;
    }
    async getSnippetFiles() {
        let filetypes = await this.getFiletypes();
        let res = [];
        for (let s of this.snippetFiles) {
            if (filetypes.indexOf(s.filetype) !== -1) {
                res.push(s.filepath);
            }
        }
        return res;
    }
    async getSnippets() {
        let doc = coc_nvim_1.workspace.getDocument(coc_nvim_1.workspace.bufnr);
        if (!doc)
            return [];
        let filetypes = await this.getFiletypes();
        filetypes.push('_');
        let snippetFiles = this.snippetFiles.filter(o => filetypes.indexOf(o.filetype) !== -1);
        let result = [];
        snippetFiles.sort((a, b) => {
            if (a.filetype == b.filetype)
                return 1;
            if (a.filetype == doc.filetype)
                return -1;
            return 1;
        });
        for (let file of snippetFiles) {
            let { snippets } = file;
            for (let snip of snippets) {
                result.push(snip);
            }
        }
        return result;
    }
    async getAllSnippetFiles() {
        let { nvim } = coc_nvim_1.workspace;
        let opt = await nvim.eval('&rtp');
        let rtps = opt.split(',');
        let res = [];
        for (let rtp of rtps) {
            let items = await this.getSnippetFileItems(path_1.default.join(rtp, 'snippets'));
            res.push(...items);
        }
        return res;
    }
    async getSnippetFileItems(directory) {
        let res = [];
        let stat = await util_1.statAsync(directory);
        if (stat && stat.isDirectory()) {
            let files = await util_1.readdirAsync(directory);
            if (files.length) {
                for (let f of files) {
                    let file = path_1.default.join(directory, f);
                    if (file.endsWith('.snippets')) {
                        let basename = path_1.default.basename(f, '.snippets');
                        let filetype = basename.split('-', 2)[0];
                        res.push({ filepath: file, directory, filetype });
                    }
                    else {
                        let stat = await util_1.statAsync(file);
                        if (stat && stat.isDirectory()) {
                            let files = await util_1.readdirAsync(file);
                            for (let filename of files) {
                                if (filename.endsWith('.snippets')) {
                                    res.push({ filepath: path_1.default.join(file, filename), directory, filetype: f });
                                }
                            }
                        }
                    }
                }
            }
        }
        return res;
    }
}
exports.SnipmateProvider = SnipmateProvider;
//# sourceMappingURL=snipmateProvider.js.map
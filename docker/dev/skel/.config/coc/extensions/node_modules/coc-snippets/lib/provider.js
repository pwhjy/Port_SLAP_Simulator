"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const coc_nvim_1 = require("coc.nvim");
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const types_1 = require("./types");
const util_1 = require("./util");
class ProviderManager {
    constructor() {
        this.providers = new Map();
    }
    regist(provider, name) {
        this.providers.set(name, provider);
        return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.providers.delete(name);
        });
    }
    get hasProvider() {
        return this.providers.size > 0;
    }
    async init() {
        let providers = Array.from(this.providers.values());
        await Promise.all(providers.map(provider => {
            return provider.init();
        }));
    }
    async getSnippets() {
        let names = Array.from(this.providers.keys());
        let list = [];
        for (let name of names) {
            let provider = this.providers.get(name);
            let snippets = await provider.getSnippets();
            snippets.map(s => s.provider = name);
            list.push(...snippets);
        }
        return list;
    }
    async getSnippetFiles() {
        let files = [];
        for (let provider of this.providers.values()) {
            let res = await provider.getSnippetFiles();
            files = files.concat(res);
        }
        return files;
    }
    async getTriggerSnippets(autoTrigger = false) {
        let bufnr = await coc_nvim_1.workspace.nvim.call('bufnr', '%');
        let doc = coc_nvim_1.workspace.getDocument(bufnr);
        if (!doc)
            return [];
        let position = await coc_nvim_1.workspace.getCursorPosition();
        let names = Array.from(this.providers.keys());
        let list = [];
        for (let name of names) {
            let provider = this.providers.get(name);
            let items = await provider.getTriggerSnippets(doc, position, autoTrigger);
            for (let item of items) {
                if (list.findIndex(o => o.prefix == item.prefix) == -1) {
                    list.push(item);
                }
            }
        }
        list.sort((a, b) => b.priority - a.priority);
        if (list.length > 1 && list[0].priority > 0) {
            list = list.filter(o => o.priority > 0);
        }
        return list;
    }
    async provideCompletionItems(document, position, _token, context) {
        let doc = coc_nvim_1.workspace.getDocument(document.uri);
        if (!doc)
            return [];
        let snippets = await this.getSnippets();
        let currline = doc.getline(position.line, true);
        let { input, col } = context.option;
        let before_content = currline.slice(0, col);
        let res = [];
        let contextPrefixes = [];
        for (let snip of snippets) {
            let contentBehind = before_content;
            if (contextPrefixes.indexOf(snip.prefix) !== -1)
                continue;
            if (snip.regex != null && snip.prefix == '')
                continue;
            if (snip.context) {
                let provider = this.providers.get(snip.provider);
                let valid = await provider.checkContext(snip.context);
                if (!valid)
                    continue;
                contextPrefixes.push(snip.prefix);
            }
            let head = this.getPrefixHead(doc, snip.prefix);
            if (input.length == 0 && !before_content.endsWith(snip.prefix))
                continue;
            let item = {
                label: snip.prefix,
                kind: vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
                filterText: snip.prefix,
                detail: snip.description,
                insertTextFormat: vscode_languageserver_protocol_1.InsertTextFormat.Snippet
            };
            item.data = {
                snip,
                provider: snip.provider,
                filepath: `${path_1.default.basename(snip.filepath)}:${snip.lnum}`
            };
            if (snip.regex) {
                if (!input.length || snip.prefix && input[0] != snip.prefix[0])
                    continue;
                let content = before_content + snip.prefix;
                let ms = content.match(snip.regex);
                if (!ms)
                    continue;
            }
            else if (head && before_content.endsWith(head)) {
                contentBehind = before_content.slice(0, -head.length);
                let prefix = snip.prefix.slice(head.length);
                Object.assign(item, {
                    textEdit: {
                        range: vscode_languageserver_protocol_1.Range.create({ line: position.line, character: col - head.length }, position),
                        newText: prefix
                    }
                });
            }
            else if (input.length == 0) {
                let { prefix } = snip;
                contentBehind = before_content.slice(0, -prefix.length);
                Object.assign(item, {
                    preselect: true,
                    textEdit: {
                        range: vscode_languageserver_protocol_1.Range.create({ line: position.line, character: col - prefix.length }, position),
                        newText: prefix
                    }
                });
            }
            if (snip.triggerKind == types_1.TriggerKind.LineBegin && contentBehind.trim().length)
                continue;
            if (snip.triggerKind == types_1.TriggerKind.SpaceBefore) {
                if (contentBehind.length && !/\s/.test(contentBehind[contentBehind.length - 1])) {
                    continue;
                }
            }
            if (!item.textEdit) {
                item.textEdit = {
                    range: vscode_languageserver_protocol_1.Range.create({ line: position.line, character: col }, position),
                    newText: item.label
                };
            }
            item.data.location = `${snip.filepath}:${snip.lnum}`;
            item.data.line = contentBehind + snip.prefix;
            res.push(item);
        }
        return res;
    }
    async resolveCompletionItem(item) {
        let provider = this.providers.get(item.data.provider);
        if (provider) {
            let filetype = await coc_nvim_1.workspace.nvim.eval('&filetype');
            let insertSnippet = await provider.resolveSnippetBody(item.data.snip, item.textEdit.range, item.data.line);
            item.textEdit.newText = insertSnippet;
            if (coc_nvim_1.snippetManager) {
                let snip = await Promise.resolve(coc_nvim_1.snippetManager.resolveSnippet(insertSnippet));
                item.documentation = {
                    kind: 'markdown',
                    value: util_1.markdownBlock(snip.toString(), filetype)
                };
            }
        }
        return item;
    }
    getPrefixHead(doc, prefix) {
        let res = 0;
        for (let idx = prefix.length - 1; idx >= 0; idx--) {
            if (!doc.isWord(prefix[idx])) {
                res = idx;
                break;
            }
        }
        return res == 0 ? '' : prefix.slice(0, res + 1);
    }
}
exports.ProviderManager = ProviderManager;
//# sourceMappingURL=provider.js.map
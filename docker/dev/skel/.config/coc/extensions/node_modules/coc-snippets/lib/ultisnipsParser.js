"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const child_process_1 = require("child_process");
const fs_1 = tslib_1.__importDefault(require("fs"));
const pify_1 = tslib_1.__importDefault(require("pify"));
const readline_1 = tslib_1.__importDefault(require("readline"));
const parser_1 = tslib_1.__importDefault(require("./parser"));
const types_1 = require("./types");
const util_1 = require("./util");
class UltiSnipsParser {
    constructor(pyMethod, channel, trace = 'error') {
        this.pyMethod = pyMethod;
        this.channel = channel;
        this.trace = trace;
    }
    parseUltisnipsFile(filepath) {
        const rl = readline_1.default.createInterface({
            input: fs_1.default.createReadStream(filepath, 'utf8'),
            crlfDelay: Infinity
        });
        let pycodes = [];
        let snippets = [];
        let block;
        let preLines = [];
        let first;
        let priority = 0;
        let lnum = 0;
        let clearsnippets = null;
        let parsedContext = null;
        let extendFiletypes = [];
        rl.on('line', line => {
            lnum += 1;
            if (!block && (line.startsWith('#') || line.length == 0))
                return;
            const [head, tail] = util_1.headTail(line);
            if (!block) {
                switch (head) {
                    case 'priority':
                        let n = parseInt(tail.trim(), 10);
                        if (!isNaN(n))
                            priority = n;
                        break;
                    case 'extends':
                        let fts = tail.trim().split(/,\s+/);
                        for (let ft of fts) {
                            if (extendFiletypes.indexOf(ft) == -1) {
                                extendFiletypes.push(ft);
                            }
                        }
                        break;
                    case 'clearsnippets':
                        clearsnippets = priority;
                        break;
                    case 'context':
                        parsedContext = tail.replace(/^"(.+)"$/, '$1');
                        break;
                    case 'snippet':
                    case 'global':
                        block = head;
                        first = tail;
                        break;
                }
                return;
            }
            if (head == 'endglobal' && block == 'global') {
                block = null;
                pycodes.push(...preLines);
                preLines = [];
                return;
            }
            if (head == 'endsnippet' && block == 'snippet') {
                block = null;
                try {
                    let originRegex;
                    let body = preLines.join('\n');
                    // convert placeholder regex to javascript regex
                    body = body.replace(/((?:[^\\]?\$\{\w+?)\/)([^\n]*?[^\\])(?=\/)/g, (_match, p1, p2) => {
                        return p1 + util_1.convertRegex(p2);
                    });
                    let ms = first.match(/^(.+?)(?:\s+(?:"(.*?)")?(?:\s+"(.*?)")?(?:\s+(\w+))?)?\s*$/);
                    let prefix = ms[1];
                    let description = ms[2] || '';
                    let context = ms[3];
                    let option = ms[4] || '';
                    if (prefix.length > 2 && prefix[0] == prefix[prefix.length - 1] && !/\w/.test(prefix[0])) {
                        prefix = prefix.slice(1, prefix.length - 1);
                    }
                    let isExpression = option.indexOf('r') !== -1;
                    let regex = null;
                    if (isExpression) {
                        originRegex = prefix;
                        prefix = util_1.convertRegex(prefix);
                        prefix = prefix.endsWith('$') ? prefix : prefix + '$';
                        try {
                            regex = new RegExp(prefix);
                            // get the real text
                            prefix = util_1.getRegexText(prefix);
                        }
                        catch (e) {
                            this.error(`Convert regex error for: ${prefix}`);
                        }
                    }
                    if (option.indexOf('e') !== -1) {
                        context = context || parsedContext;
                    }
                    else {
                        context = null;
                    }
                    let snippet = {
                        filepath,
                        context,
                        originRegex,
                        autoTrigger: option.indexOf('A') !== -1,
                        lnum: lnum - preLines.length - 2,
                        triggerKind: getTriggerKind(option),
                        prefix,
                        description,
                        regex,
                        body,
                        priority
                    };
                    snippets.push(snippet);
                }
                catch (e) {
                    this.error(`Create snippet error on: ${filepath}:${lnum - preLines.length - 1} ${e.message}`);
                }
                finally {
                    parsedContext = null;
                    preLines = [];
                }
            }
            if (block == 'snippet' || block == 'global') {
                preLines.push(line);
                return;
            }
        });
        return new Promise(resolve => {
            rl.on('close', async () => {
                resolve({ snippets, clearsnippets, pythonCode: pycodes.join('\n'), extendFiletypes });
            });
        });
    }
    async resolveUltisnipsBody(body) {
        let { pyMethod } = this;
        let parser = new parser_1.default(body);
        let resolved = '';
        while (!parser.eof()) {
            let p = parser.prev();
            if (parser.curr == '`' && (!p || p != '\\')) {
                let idx = parser.nextIndex('`', true, false);
                if (idx == -1) {
                    resolved = resolved + parser.eatTo(parser.len);
                    break;
                }
                let code = parser.eatTo(idx + 1);
                code = code.slice(1, -1);
                resolved = resolved + await this.execute(code, pyMethod);
                continue;
            }
            else if (parser.curr == '$') {
                let text = parser.next(7);
                if (text.startsWith('VISUAL') || text.startsWith('{VISUAL')) {
                    parser.eat(8);
                    resolved = resolved + '$' + text.replace('VISUAL', 'TM_SELECTED_TEXT');
                }
                else {
                    // skip current
                    resolved += parser.eat(1);
                }
            }
            let prev = parser.prev() || '';
            parser.iterate(ch => {
                if (prev !== '\\' && (ch == '`' || ch == '$')) {
                    return false;
                }
                else {
                    resolved = resolved + ch;
                }
                prev = ch;
                return true;
            });
        }
        resolved = decode(resolved);
        this.debug(`resolved: ${resolved}`);
        return resolved;
    }
    async execute(code, pyMethod) {
        let { nvim } = require('coc.nvim').workspace;
        if (!nvim)
            return code;
        let res = '';
        if (code.startsWith('!')) {
            code = code.trim().slice(1);
            if (code.startsWith('p')) {
                code = code.slice(1).trim();
                let lines = code.split('\n');
                lines = lines.map(line => line.replace(/\t/g, '    '));
                lines = lines.map(line => `    ${line}`);
                lines.unshift('try:');
                lines.unshift('import traceback');
                lines.push('except Exception as e:');
                lines.push('    snip.rv = traceback.format_exc()');
                await nvim.command(`${pyMethod} ${lines.join('\n')}`);
                res = await nvim.call(`${pyMethod}eval`, 'snip.rv');
            }
            else if (code.startsWith('v')) {
                code = code.replace(/^v\s*/, '');
                try {
                    res = await nvim.eval(code);
                    res = res.toString();
                }
                catch (e) {
                    res = `Error: ${e.message}`;
                    this.error(e.stack);
                }
            }
        }
        else {
            try {
                res = await pify_1.default(child_process_1.exec)(code);
                res = res.replace(/\r?\n$/, '');
            }
            catch (e) {
                res = `Error: ${e.message}`;
                this.error(`Error on eval ${code}: ` + e.stack);
            }
        }
        return res;
    }
    error(str) {
        if (!this.channel)
            return;
        this.channel.appendLine(`[Error ${(new Date()).toLocaleTimeString()}] ${str}`);
    }
    debug(str) {
        if (!this.channel || this.trace == 'error')
            return;
        this.channel.appendLine(`[Debug ${(new Date()).toLocaleTimeString()}] ${str}`);
    }
}
exports.default = UltiSnipsParser;
function decode(str) {
    return str.replace(/\\`/g, '`').replace(/\\{/g, '{');
}
function getTriggerKind(option) {
    if (option.indexOf('w') !== -1) {
        return types_1.TriggerKind.WordBoundary;
    }
    if (option.indexOf('b') !== -1) {
        return types_1.TriggerKind.LineBegin;
    }
    if (option.indexOf('i') !== -1) {
        return types_1.TriggerKind.InWord;
    }
    return types_1.TriggerKind.SpaceBefore;
}
//# sourceMappingURL=ultisnipsParser.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/******************************************************************
MIT License http://www.opensource.org/licenses/mit-license.php
Author Qiming Zhao <chemzqm@gmail> (https://github.com/chemzqm)
*******************************************************************/
const coc_nvim_1 = require("coc.nvim");
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
const baseProvider_1 = tslib_1.__importDefault(require("./baseProvider"));
const types_1 = require("./types");
const ultisnipsParser_1 = tslib_1.__importDefault(require("./ultisnipsParser"));
const util_1 = require("./util");
class UltiSnippetsProvider extends baseProvider_1.default {
    constructor(channel, trace, config) {
        super(config);
        this.channel = channel;
        this.trace = trace;
        this.config = config;
        this.snippetFiles = [];
        this.disposables = [];
        this.directories = this.config.directories.map(s => {
            return s.startsWith('~') ? os_1.default.homedir() + s.slice(1) : s;
        });
    }
    async init() {
        let { config, directories } = this;
        let hasPythonx = await coc_nvim_1.workspace.nvim.call('has', ['pythonx']);
        this.pythonCode = await util_1.readFileAsync(path_1.default.join(__dirname, '../python/ultisnips.py'), 'utf8');
        if (hasPythonx && config.usePythonx) {
            this.pyMethod = 'pyx';
        }
        else {
            this.pyMethod = config.pythonVersion == 3 ? 'py3' : 'py';
        }
        this.parser = new ultisnipsParser_1.default(this.pyMethod, this.channel, this.trace);
        let arr = await this.getAllSnippetFiles();
        await Promise.all(arr.map(({ filepath, directory, filetype }) => {
            return this.loadSnippetsFromFile(filetype, directory, filepath);
        }));
        if (this.pythonCode) {
            let { nvim } = coc_nvim_1.workspace;
            let tmpfile = path_1.default.join(os_1.default.tmpdir(), 'coc-ultisnips.py');
            await util_1.writeFileAsync(tmpfile, this.pythonCode);
            let escaped = await nvim.call('fnameescape', tmpfile);
            coc_nvim_1.workspace.nvim.command(`${this.pyMethod}file ${escaped}`, true);
        }
        let watchmanPath = coc_nvim_1.workspace.getWatchmanPath();
        if (!watchmanPath) {
            coc_nvim_1.workspace.onDidSaveTextDocument(async (doc) => {
                let filepath = vscode_uri_1.default.parse(doc.uri).fsPath;
                let snippetFile = this.snippetFiles.find(s => s.filepath == filepath);
                if (snippetFile) {
                    await this.loadSnippetsFromFile(snippetFile.filetype, snippetFile.directory, filepath);
                }
                else {
                    let filetype = path_1.default.basename(filepath, '.snippets');
                    await this.loadSnippetsFromFile(filetype, path_1.default.dirname(filepath), filepath);
                }
            }, null, this.disposables);
        }
        else {
            for (let dir of directories) {
                if (!path_1.default.isAbsolute(dir))
                    continue;
                let watchman = new coc_nvim_1.Watchman(watchmanPath, this.channel);
                await watchman.watchProject(dir);
                let disposable = await watchman.subscribe('**/*.snippets', async (change) => {
                    let { files } = change;
                    files = files.filter(f => f.type == 'f');
                    for (let fileItem of files) {
                        let filepath = path_1.default.join(dir, fileItem.name);
                        if (!fileItem.exists) {
                            let idx = this.snippetFiles.findIndex(o => o.filepath == filepath);
                            if (idx !== -1)
                                this.snippetFiles.splice(idx, 1);
                        }
                        else {
                            let snippetFile = this.snippetFiles.find(s => s.filepath == filepath);
                            if (snippetFile) {
                                await this.loadSnippetsFromFile(snippetFile.filetype, snippetFile.directory, filepath);
                            }
                            else {
                                let filetype = path_1.default.basename(filepath, '.snippets');
                                await this.loadSnippetsFromFile(filetype, path_1.default.dirname(filepath), filepath);
                            }
                        }
                    }
                });
                this.disposables.push(disposable);
            }
        }
    }
    async loadSnippetsFromFile(filetype, directory, filepath) {
        let { snippets, pythonCode, extendFiletypes, clearsnippets } = await this.parser.parseUltisnipsFile(filepath);
        let idx = this.snippetFiles.findIndex(o => o.filepath == filepath);
        if (idx !== -1)
            this.snippetFiles.splice(idx, 1);
        this.snippetFiles.push({
            extendFiletypes,
            clearsnippets,
            directory,
            filepath,
            filetype,
            snippets
        });
        if (extendFiletypes) {
            let filetypes = this.config.extends[filetype] || [];
            filetypes = filetypes.concat(extendFiletypes);
            this.config.extends[filetype] = util_1.distinct(filetypes);
        }
        if (this.trace == 'verbose') {
            this.channel.appendLine(`[Info ${(new Date()).toLocaleTimeString()}] Loaded ${snippets.length} snippets from: ${filepath}`);
        }
        this.pythonCode = this.pythonCode + '\n' + pythonCode;
    }
    async resolveSnippetBody(snippet, range, line) {
        let { nvim } = coc_nvim_1.workspace;
        let { body, context, originRegex } = snippet;
        let buf = await nvim.buffer;
        let filepath = await buf.name;
        let indentCount = await nvim.call('indent', '.');
        let ind = ' '.repeat(indentCount);
        if (body.indexOf('`!p') !== -1) {
            let values = new Map();
            body.replace(/\$\{(\d+):([^}]+)\}/g, (_, p1, p2) => {
                if (p1 == 0)
                    return '';
                values.set(Number(p1), p2);
            });
            let indexes = Array.from(values.keys());
            indexes.sort((a, b) => a - b);
            let vals = indexes.map(idx => values.get(idx));
            vals = vals.map(s => `'${s.replace(/'/g, "\\'")}'`);
            let pyCodes = [];
            pyCodes.push('import re, os, vim, string, random');
            pyCodes.push(`t = ('', ${vals.join(',')})`);
            pyCodes.push(`fn = '${path_1.default.basename(filepath)}'`);
            pyCodes.push(`path = '${filepath}'`);
            if (context) {
                pyCodes.push(`snip = ContextSnippet()`);
                pyCodes.push(`context = ${context}`);
            }
            else {
                pyCodes.push(`context = {}`);
            }
            let start = `(${range.start.line},${Buffer.byteLength(line.slice(0, range.start.character))})`;
            let end = `(${range.end.line},${Buffer.byteLength(line.slice(0, range.end.character))})`;
            pyCodes.push(`snip = SnippetUtil('${ind}', ${start}, ${end}, context)`);
            if (originRegex) {
                pyCodes.push(`pattern = re.compile(r"${originRegex.replace(/"/g, '\\"')}")`);
                pyCodes.push(`match = pattern.search("${line.replace(/"/g, '\\"')}")`);
            }
            await nvim.command(`${this.pyMethod} ${pyCodes.join('\n')}`);
        }
        return this.parser.resolveUltisnipsBody(body);
    }
    async checkContext(context) {
        let { nvim } = coc_nvim_1.workspace;
        let pyCodes = [];
        pyCodes.push('import re, os, vim, string, random');
        pyCodes.push(`snip = ContextSnippet()`);
        pyCodes.push(`context = ${context}`);
        await nvim.command(`${this.pyMethod} ${pyCodes.join('\n')}`);
        let res = await nvim.call(`${this.pyMethod}eval`, 'True if context else False');
        return res;
    }
    async getTriggerSnippets(document, position, autoTrigger) {
        let snippets = await this.getSnippets();
        let line = document.getline(position.line);
        line = line.slice(0, position.character);
        if (!line || line[line.length - 1] == ' ')
            return [];
        snippets = snippets.filter(s => {
            let { prefix, regex } = s;
            if (autoTrigger && !s.autoTrigger)
                return false;
            if (regex) {
                let ms = line.match(regex);
                if (!ms)
                    return false;
                prefix = ms[0];
            }
            if (!line.endsWith(prefix))
                return false;
            if (s.triggerKind == types_1.TriggerKind.InWord)
                return true;
            let pre = line.slice(0, line.length - prefix.length);
            if (s.triggerKind == types_1.TriggerKind.LineBegin)
                return pre.trim() == '';
            if (s.triggerKind == types_1.TriggerKind.SpaceBefore)
                return pre.length == 0 || /\s/.test(pre[pre.length - 1]);
            if (s.triggerKind == types_1.TriggerKind.WordBoundary)
                return pre.length == 0 || !document.isWord(pre[pre.length - 1]);
            return false;
        });
        let edits = [];
        let contextPrefixes = [];
        for (let s of snippets) {
            let character;
            if (s.context) {
                let valid = await this.checkContext(s.context);
                if (!valid)
                    continue;
                contextPrefixes.push(s.context);
            }
            else if (contextPrefixes.indexOf(s.prefix) !== -1) {
                continue;
            }
            if (s.regex == null) {
                character = position.character - s.prefix.length;
            }
            else {
                let len = line.match(s.regex)[0].length;
                character = position.character - len;
            }
            let range = vscode_languageserver_types_1.Range.create(position.line, character, position.line, position.character);
            let newText = await this.resolveSnippetBody(s, range, line);
            edits.push({
                prefix: s.prefix,
                description: s.description,
                location: s.filepath,
                priority: s.priority,
                range,
                newText,
            });
        }
        return edits;
    }
    async getSnippetFiles() {
        let filetypes = await this.getFiletypes();
        let res = [];
        for (let s of this.snippetFiles) {
            if (filetypes.indexOf(s.filetype) !== -1) {
                res.push(s.filepath);
            }
        }
        return res;
    }
    async getSnippets() {
        let doc = coc_nvim_1.workspace.getDocument(coc_nvim_1.workspace.bufnr);
        if (!doc)
            return;
        let filetypes = await this.getFiletypes();
        filetypes.push('all');
        let snippetFiles = this.snippetFiles.filter(o => filetypes.indexOf(o.filetype) !== -1);
        let min = null;
        let result = [];
        snippetFiles.sort((a, b) => {
            if (a.filetype == b.filetype)
                return 1;
            if (a.filetype == doc.filetype)
                return -1;
            return 1;
        });
        for (let file of snippetFiles) {
            let { snippets, clearsnippets } = file;
            if (typeof clearsnippets == 'number') {
                min = min ? Math.max(min, clearsnippets) : clearsnippets;
            }
            for (let snip of snippets) {
                if (snip.regex || snip.context) {
                    result.push(snip);
                }
                else {
                    let idx = result.findIndex(o => o.prefix == snip.prefix && o.triggerKind == snip.triggerKind);
                    if (idx == -1) {
                        result.push(snip);
                    }
                    else {
                        let item = result[idx];
                        if (snip.priority > item.priority) {
                            result[idx] = item;
                        }
                    }
                }
            }
        }
        if (min != null)
            result = result.filter(o => o.priority >= min);
        result.sort((a, b) => {
            if (a.context && !b.context)
                return -1;
            if (b.context && !a.context)
                return 1;
            return 0;
        });
        return result;
    }
    async getAllSnippetFiles() {
        let { nvim } = coc_nvim_1.workspace;
        let { directories } = this;
        let res = [];
        let folders = [];
        for (let directory of directories) {
            if (path_1.default.isAbsolute(directory)) {
                let items = await this.getSnippetFileItems(directory);
                res.push(...items);
            }
            else {
                folders.push(directory);
            }
        }
        if (folders.length) {
            let opt = await nvim.eval('&rtp');
            let rtps = opt.split(',');
            for (let rtp of rtps) {
                for (let directory of folders) {
                    let items = await this.getSnippetFileItems(path_1.default.join(rtp, directory));
                    res.push(...items);
                }
            }
        }
        return res;
    }
    async getSnippetFileItems(directory) {
        let res = [];
        let stat = await util_1.statAsync(directory);
        if (stat && stat.isDirectory()) {
            let files = await util_1.readdirAsync(directory);
            if (files.length) {
                for (let f of files) {
                    let file = path_1.default.join(directory, f);
                    if (file.endsWith('.snippets')) {
                        let basename = path_1.default.basename(f, '.snippets');
                        let filetype = basename.split('_', 2)[0];
                        res.push({ filepath: file, directory, filetype });
                    }
                    else {
                        let stat = await util_1.statAsync(file);
                        if (stat && stat.isDirectory()) {
                            let files = await util_1.readdirAsync(file);
                            for (let filename of files) {
                                if (filename.endsWith('.snippets')) {
                                    res.push({ filepath: path_1.default.join(file, filename), directory, filetype: f });
                                }
                            }
                        }
                    }
                }
            }
        }
        return res;
    }
    dispose() {
        coc_nvim_1.disposeAll(this.disposables);
    }
}
exports.UltiSnippetsProvider = UltiSnippetsProvider;
//# sourceMappingURL=ultisnipsProvider.js.map